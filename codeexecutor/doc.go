// Copyright 2025 The Go A2A Authors
// SPDX-License-Identifier: Apache-2.0

// Package codeexecutor provides secure code execution with multiple backends and safety controls.
//
// The codeexecutor package implements the types.CodeExecutor interface with three distinct
// execution backends, each offering different levels of security and functionality for
// running code generated by agents or provided by users.
//
// # Execution Backends
//
// The package provides three execution strategies:
//
//   - BuiltInExecutor: Uses model's native code execution (Gemini 2.0+)
//   - ContainerExecutor: Docker-based sandboxing with resource limits
//   - LocalExecutor: Direct host execution (requires explicit opt-in)
//
// # Security Model
//
// Execution backends are ordered by security level:
//
//  1. BuiltInExecutor: Safest - Uses model's built-in sandboxed execution
//  2. ContainerExecutor: Secure - Docker isolation with network restrictions
//  3. LocalExecutor: Unsafe - Direct host execution (development only)
//
// The choice of executor depends on security requirements and available infrastructure.
//
// # Basic Usage
//
// Creating executors:
//
//	// Built-in executor (safest)
//	executor := codeexecutor.NewBuiltInExecutor()
//
//	// Container executor (secure)
//	executor, err := codeexecutor.NewContainerExecutor(
//		codeexecutor.WithImage("python:3.11-slim"),
//		codeexecutor.WithTimeout(30*time.Second),
//	)
//
//	// Local executor (unsafe - requires explicit opt-in)
//	executor := codeexecutor.NewLocalExecutor(
//		codeexecutor.WithAllowUnsafe(true),
//		codeexecutor.WithWorkDir("/tmp/code-execution"),
//	)
//
// Executing code:
//
//	input := &types.CodeExecutionInput{
//		Code:     "print('Hello, World!')",
//		Language: "python",
//	}
//
//	result, err := executor.ExecuteCode(ctx, invocationContext, input)
//	if err != nil {
//		log.Fatal(err)
//	}
//
//	fmt.Println("Output:", result.Output)
//	fmt.Println("Exit Code:", result.ExitCode)
//
// # Execution Features
//
// Stateful Execution:
//   - Variables and imports persist across Execute calls
//   - Useful for iterative development and data analysis
//   - Configurable via execution options
//
// Long-Running Operations:
//   - Support for operations that take extended time
//   - Proper timeout and cancellation handling
//   - Progress reporting capabilities
//
// Data File Optimization:
//   - Automatic extraction and processing of CSV and data files
//   - Direct file attachment to execution environment
//   - Optimized for large datasets
//
// # Configuration Options
//
// Executors support extensive configuration:
//
//	executor := codeexecutor.NewContainerExecutor(
//		codeexecutor.WithStateful(true),           // Enable stateful execution
//		codeexecutor.WithLongRunning(true),        // Support long operations
//		codeexecutor.WithOptimizeDataFiles(true),  // Optimize data file handling
//		codeexecutor.WithMaxRetries(3),            // Retry failed executions
//		codeexecutor.WithRetryDelay(time.Second),  // Delay between retries
//		codeexecutor.WithTimeout(60*time.Second),  // Execution timeout
//	)
//
// # Language Support
//
// The package supports multiple programming languages:
//   - Python (most common for AI/ML tasks)
//   - JavaScript/Node.js
//   - R (data analysis)
//   - Bash/Shell scripts
//   - Custom language support via container images
//
// Language detection is automatic based on code patterns and explicit hints.
//
// # Container Execution
//
// ContainerExecutor provides robust sandboxing:
//
//	executor, err := codeexecutor.NewContainerExecutor(
//		codeexecutor.WithImage("python:3.11-slim"),
//		codeexecutor.WithMemoryLimit("512m"),
//		codeexecutor.WithCPULimit("1.0"),
//		codeexecutor.WithNetworkDisabled(true),
//		codeexecutor.WithTimeout(30*time.Second),
//	)
//
// Features:
//   - Resource limits (memory, CPU, disk)
//   - Network isolation
//   - Filesystem sandboxing
//   - Custom Docker images
//   - Automatic cleanup
//
// # Error Handling and Retries
//
// Robust error handling with configurable retry logic:
//
//	// Execution errors are automatically retried
//	result, err := executor.ExecuteCode(ctx, ictx, input)
//	if err != nil {
//		// Check if retries were exhausted
//		if execErr, ok := err.(*types.ExecutionError); ok {
//			fmt.Printf("Failed after %d attempts\n", execErr.Attempts)
//		}
//	}
//
// # Integration with Agents
//
// Code executors integrate seamlessly with the agent system:
//
//	agent := agent.NewLLMAgent(ctx, "coder",
//		agent.WithCodeExecutor(executor),
//		agent.WithInstruction("You can execute code to solve problems"),
//	)
//
// Agents automatically:
//   - Extract code blocks from responses
//   - Execute code using the configured executor
//   - Include execution results in conversation context
//   - Handle errors and retries transparently
//
// # Thread Safety
//
// All executors are safe for concurrent use. However, stateful executors
// maintain per-session state, so concurrent executions within the same
// session may interfere with each other.
//
// # Resource Management
//
// Proper resource cleanup is essential:
//
//	defer executor.Close() // Always close executors
//
// Executors manage:
//   - Docker containers and images
//   - Temporary files and directories
//   - Network connections
//   - Background processes
//
// # Best Practices
//
//  1. Use BuiltInExecutor when supported by the model
//  2. Use ContainerExecutor for production deployments
//  3. Never use LocalExecutor in production
//  4. Always set appropriate timeouts
//  5. Configure resource limits for containers
//  6. Handle errors and retries appropriately
//  7. Close executors when done
package codeexecutor

